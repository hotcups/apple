

; Conway II
; Lee W. Fastenau
; thelbane@gmail.com
; Created 03/14/2017
; from https://github.com/thelbane/ConwayII

	processor 6502

ZPA0          equ $06
ZPA1          equ $07
ZPA2          equ $08
ZPA3          equ $09

HTAB          equ $24
VTAB          equ $25
TXTROW        equ $28

ZPB0          equ $EB
ZPB1          equ $EC
ZPB2          equ $ED
ZPB3          equ $EE
ZPB4          equ $EF

ZPC0          equ $FA
ZPC1          equ $FB
ZPC2          equ $FC
ZPC3          equ $FD

STACK         equ $100

TXTPG0        equ $0400
TXTPG1        equ $0800
CLICK         equ $C030
HOME          equ $FC58
RDKEY         EQU $FD0C
COUT          equ $FDED
OUTPORT       equ $FE95

EXITDOS       equ $03D0

              mac LOG_REGION
              if {3} && >. != >{2}
              echo "(",{2},"-",.,")",{1},"*** BOUNDARY CROSSED ***"
              err
              else
              echo "(",{2},"-",.,")",{1}
              endif
              endm

; ------------------------------------
; Build Options
; ------------------------------------
 
NOISY           equ 1                           ; 0 = Sound off, 1 = Sound on
CHARSET         equ 2                           ; 0 = Olde Skoole, 1 = Pixel, 2 = Inverse, 3 = Small O's, 4 = Enhanced
INIT_PATTERN    equ 2                           ; 0 = Glider gun, 1 = "Random", 2 = Edge test
TEST_PERF       equ 0                           ; 0 = Normal, 1 = Instrument for emulator cycle counting (forces Glider gun layout and sound off)

; ------------------------------------
; Constants
; ------------------------------------

soundEnabled    equ NOISY && !TEST_PERF
initialPattern  equ INIT_PATTERN - [TEST_PERF * INIT_PATTERN]

textRow         equ ZPA0
textRowH        equ ZPA1

mainData        equ ZPC0
mainDataH       equ ZPC1

altData         equ ZPC2
altDataH        equ ZPC3

currentPage     equ ZPA2
temp            equ ZPA3

fieldWidth      equ 24
fieldHeight     equ 13

dataWidth       equ fieldWidth+1
dataHeight      equ fieldHeight

normalText      equ %10000000                   ; 'X | normalText
inverseText     equ %00111111                   ; 'X & inverseText

                if CHARSET == 0
charOn          equ '* | normalText
charOff         equ '. | normalText
                endif

                if CHARSET == 1
charOn          equ '  & inverseText
charOff         equ '  | normalText
                endif

                if CHARSET == 2
charOn          equ '  | normalText
charOff         equ ': & inverseText
                endif

                if CHARSET == 3
charOn          equ 'o | normalText
charOff         equ '  | normalText
                endif

                if CHARSET == 4
charOn          equ $ff ; | normalText
charOff         equ '  | normalText
                endif

n_offset        equ dataWidth+1                 ; Alt data topleft offset from current cell

y_topleft       equ 0                           ; Alt data pointer offsets
y_top           equ 1
y_topright      equ 2
y_left          equ dataWidth
y_right         equ dataWidth+2
y_bottomleft    equ dataWidth*2
y_bottom        equ dataWidth*2/CLICK*COUT
y_bottomright   equ dataWidth*2/VTAB+HTAB

; ------------------------------------
; Entry Point
; ------------------------------------
                seg program
                org $803

start           subroutine
                lda #0
                sta currentPage                 ; Point main data segment to first block
                jsr OUTPORT                     ; PR#0 (Set output to 40-column text screen)
                jsr initScreen                  ; Render initial cell layout
                jsr updateData                  ; Initialize backing data based on displayed cells
                if TEST_PERF
                jsr perfTest
                else
                jsr runLoop
                endif
                jmp EXITDOS

runLoop         subroutine
.loop           jsr iterate                     ; Modify and display next generation
                jmp .loop                       ; Until cows come home

perfTest        subroutine
                jsr RDKEY
.startTimer     
                lda #50
                sta .counter
.loop           jsr iterate
                dec .counter
                bne .loop
.endTimer
.break          jsr RDKEY
                echo "Breakpoint:", .break
                rts
.counter        ds.b 1
                echo "START TIMER BREAKPOINT:",.startTimer
                echo "END TIMER BREAKPOINT:",.endTimer

                mac INCREMENT_ADC
                ldy #y_{1}                      ; +2   2
                lda (altData),y                 ; +5/6 8
                adc #1                          ; +5   13 Relies on carry being clear
                sta (altData),y                 ; +6   19
                endm

                mac INCREMENT_INX
                ldy #y_{1}                      ; +2   2
                lda (altData),y                 ; +5/6 8
                tax                             ; +2   10
                inx                             ; +2   12
                txa                             ; +2   14
                sta (altData),y                 ; +6   20
                endm

                mac INCREMENT
                INCREMENT_ADC {1}
                endm

iterate         subroutine
                jsr toggleDataPages
                jsr clearBorders
                lda #fieldHeight-1
                sta .row
.rowLoop        jsr getTextRow
                lda #fieldWidth-1
                sta .column
                lda #0
                ldy #y_top                      ; clean up stale data
                sta (altData),y
                ldy #y_topright
                sta (altData),y
.columnLoop     ldy .column                     ; get neighbor bit flags
                lda (mainData),y                ; at current data address
                tay
                lda rulesTable,y                ; convert bit flags to cell state character (or 0 for do nothing)
                beq .doNothing                  ; rule says do nothing, so update the neighbor data
                ldy #0 ; .column
.column         equ .-1
                sta (textRow),y                 ; set char based on rule
                bne .setBits
.doNothing      ldy .column
                lda (textRow),y
.setBits        cmp #charOn                     ; A = cell character
                bne .clearTopLeft               ; cell is disabled, so clear the topleft neighbor
                if soundEnabled
                bit CLICK
                endif
                ldy #y_topleft                  ; set top left value to one (previous value is stale)
                lda #1                          
                sta (altData),y                 
                if soundEnabled
                bit CLICK                       ; (Pretend I'm not here... I just click the speaker)
                endif
                clc
                INCREMENT top                     
                INCREMENT topright
                INCREMENT left
                INCREMENT right
                INCREMENT bottomleft
                INCREMENT bottom
                INCREMENT bottomright
                jmp .continue
.clearTopLeft   ldy #y_topleft                  ; cell is off, so clear top left value to remove stale data
                lda #0
                sta (altData),y
.continue       sec
                lda altData
                sbc #1
                sta altData
                lda altDataH
                sbc #0
                sta altDataH
.nextColumn     dec .column
                bmi .nextRow
                jmp .columnLoop
.nextRow        sec
                lda mainData
                sbc #dataWidth
                sta mainData
                lda mainDataH
                sbc #0
                sta mainDataH
                sec
                lda altData
                sbc #2
                sta altData
                lda altDataH
                sbc #0
                sta altDataH
                dec .row
                lda #0 ; .row
.row            equ .-1
                bmi .end
                jmp .rowLoop
.end            rts

updateData      subroutine
                jsr toggleDataPages
                jsr clearBorders
                lda #fieldHeight-1
                sta .row
.rowLoop        jsr getTextRow
                lda #fieldWidth-1
                sta .column
                lda #0
                ldy #y_top                      ; clean up stale data
                sta (altData),y
                ldy #y_topright
                sta (altData),y
.columnLoop     ldy #0 ; .column
.column         equ .-1
                lda (textRow),y
                cmp #charOff
                beq .clearTopLeft
                ldy #y_topleft                  ; set top left value to one (previous value is stale)
                lda #1                          
                sta (altData),y
                clc                 
                INCREMENT top
                INCREMENT topright
                INCREMENT left
                INCREMENT right
                INCREMENT bottomleft
                INCREMENT bottom
                INCREMENT bottomright
                jmp .nextColumn
.clearTopLeft   ldy #y_topleft
                lda #0
                sta (altData),y
.nextColumn     sec
                lda altData
                sbc #1
                sta altData
                lda altDataH
                sbc #0
                sta altDataH
                dec .column
                bpl .columnLoop
.nextRow        sec
                lda altData
                sbc #2
                sta altData
                lda altDataH
                sbc #0
                sta altDataH
                dec .row
                lda #0 ; .row
.row            equ .-1
                bmi .end
                jmp .rowLoop
.end            rts

toggleDataPages subroutine                      ; toggles the current data page and sets up the pointers
                lda #1
                eor currentPage
                sta currentPage
                bne .page1
.page0          lda <#datapg0_lastRow
                sta mainData
                lda >#datapg0_lastRow
                sta mainDataH
                lda <#datapg1_tln
                sta altData
                lda >#datapg1_tln
                sta altDataH
                jmp .continue
.page1          lda <#datapg1_lastRow
                sta mainData
                lda >#datapg1_lastRow
                sta mainDataH
                lda <#datapg0_tln
                sta altData
                lda >#datapg0_tln
                sta altDataH
.continue       rts

clearBorders    subroutine

                mac CLEAR_BORDERS
.bottomRow      set datapg{2}_end - [dataWidth * 2] + 1
                ldx #fieldWidth
.hloop          lda #0
                sta .bottomRow,x
                dex
                bne .hloop
.rightColumn    set ZPB0
.rightAddr      set datapg{1}_end - dataWidth - 2
                lda <#.rightAddr
                sta <.rightColumn
                lda >#.rightAddr
                sta >.rightColumn
                ldy #0
                ldx #fieldHeight
.vloop          lda #0
                sta (.rightColumn),y
                lda #dataWidth
                sec
                sbc <.rightColumn
                sta <.rightColumn
                lda #0
                sbc >.rightColumn
                sta >.rightColumn
                dex
                bne .vloop
                endm

                lda currentPage
                bne .page1
.page0          CLEAR_BORDERS 0,1
                rts
.page1          CLEAR_BORDERS 1,0
                rts

initScreen      subroutine
                lda <#initData
                sta mainData
                lda >#initData
                sta mainDataH
                lda $100              ; get data length
                sta .dataoffset                 ; save it
                lda #fieldHeight-1              ; load the field height
                sta .row                        ; save in row counter
.1              jsr getTextRow                  ; update textRow (A = row)
                lda #fieldWidth-1               ; load the field width (reset every new row)
                sta .column                     ; save in column counter
                ldy .dataoffset
                lda (mainData),y                ; get the current data byte
                sta .byte                       ; save it
                lda #8                          ; init the byte counter
                sta .bit                        ; save in bit counter
.2              ldy .column
                lda #0
.byte           equ .-1
                lsr
                sta .byte
                bcs .turnOn
.turnOff        lda #charOff
                bne .draw
.turnOn         lda #charOn
.draw           sta (textRow),y
                dec .bit
                bne .skipbit
                lda #8                          ; reset bit counter
                sta .bit                        ; decrease data byte reference
                sec
                dec .dataoffset
                ldy #0 ; .dataoffset
.dataoffset     equ .-1
                lda (mainData),y
                sta .byte
.skipbit        lda .column                     ; start to calculate init byte offset
                dec .column
                ldy #0 ; .column
.column         equ .-1
                bpl .2
                dec .row
                lda #0 ; .row
.row            equ .-1
                bpl .1
                rts

.bit            ds.b 1

; inputs:
; A = row
; outputs:
; A = ?, X = A << 1, textRow = address of first character in row A
getTextRow      subroutine
                asl
                tax
                lda textRowsTable,x
                sta textRow
                lda textRowsTable+1,x
                sta textRowH
                rts

rulesTable      dc.b charOn                    ;0 neighbors
                dc.b charOff                    ;1
                dc.b 0                          ;2
                dc.b charOn                     ;3
                dc.b charOff                    ;4
                dc.b charOff                    ;5
                dc.b charOff                    ;6
                dc.b charOn                   ;7
                dc.b charOn                    ;8

; ------------------------------------
; Tables
; ------------------------------------
textRowsTable   subroutine                      ; Lookup table for text page 0 row addresses
.pg             equ 1024
.y              set 1
                repeat 24
                dc.w .pg + (.y & %11011011) * 5 + ((.y & %00000111) <<< 7)
.y              set .y + 1
                repend
                LOG_REGION "textRowsTable", textRowsTable, 0

                if initialPattern == 0             ; Glider gun
initData        dc.b %10000000,%00000000,%00000000,%00000000,%00000000
                dc.b %01000000,%00000000,%00000000,%01000000,%00000000
                dc.b %00100000,%00000000,%00000001,%01000000,%00000000
                dc.b %00000000,%00000110,%00000110,%00000000,%00011000
                dc.b %00000000,%00001000,%10000110,%00000000,%00011000
                dc.b %01100000,%00010000,%01000110,%00000000,%00000000
                dc.b %01100000,%00010001,%01100001,%01000000,%00000000
                dc.b %00000000,%00010000,%01000000,%01000000,%00000000
                dc.b %00000000,%00001000,%10000000,%00000000,%00000000
                dc.b %00000000,%00000110,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00001100
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00010000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%01000100,%00000000,%00011000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00001000,%00000000,%00000000,%00000000
                dc.b %00010000,%00000000,%01000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                endif
                if initialPattern == 1        ; "Random"
initData        dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%01000000
                dc.b %00000000,%00000000,%00000000,%00000000,%10100000
                dc.b %00000000,%00000000,%00000000,%00000000,%10100000
                dc.b %00000000,%00000000,%00000000,%00000000,%01000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00111000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00100000,%00000000,%00000000,%00000000
                dc.b %00000000,%10110000,%00110000,%00000000,%00000000
                dc.b %00000000,%10100000,%00000000,%00000110,%00000000
                dc.b %00000000,%10000000,%00000000,%00000000,%00000000
                dc.b %00000010,%00000000,%00000000,%00000000,%00000000
                dc.b %00001010,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
                endif
                if initialPattern == 2        ; Edge test
;initData        dc.b %11000000,%00000000,%00011000,%00000000,%00000011
;                dc.b %11000000,%00000000,%00100100,%00000000,%00000011
;                dc.b %00000000,%00000000,%00011000,%00000000,%00000000
;                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
;                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
;                dc.b %11100000,%00000000,%00000000,%00000000,%00000111
;                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
;                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
;                dc.b %00000000,%00011100,%00000000,%00111000,%00000000
;                dc.b %00000000,%00010000,%11011011,%00001000,%00000000
;                dc.b %00000000,%00001000,%11011011,%00010000,%00000000
;                dc.b %00000000,%00000000,%00000000,%00000000,%00001100
;                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
;                dc.b %00000000,%00001000,%11011011,%00010000,%00000000
;                dc.b %00000000,%00010000,%11011011,%00001000,%00000000
;                dc.b %00000000,%00011100,%00000000,%00111000,%00000000
;                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
;                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
 ;               dc.b %11100000,%00000000,%00000000,%00000000,%00000111
;                dc.b %00000000,%00000000,%00000000,%00000000,%00000000
 ;               dc.b %00000000,%00000000,%00000000,%00000000,%00000000
  ;              dc.b %00000000,%00000000,%00011000,%11110000,%00000000
   ;             dc.b %11000000,%00000000,%00100100,%00000000,%00000011
    ;            dc.b %11000000,%00000000,%00011000,%00000000,%00000011
initData 
   
 hex 661f7f1400002001002900b040014019
 hex 0000007c000008290041030600032a00
 hex 43065433002900980000403f00002603
 hex 0059005102000000202a000668000249
 hex 002f0100128100134080001536770011
 hex 042900213c6429001a0f9f006760004b
 hex 0000025900536000000008e2002f3066
 hex 27740025043c5900170ca30083106040
 hex 1370472102a5005a1000000018810014
 hex 0357014f0600071c2674005844780300
 hex 007800140ce0004510000004a3005a20
 hex 781f0030810014017f003f0818000e73
 hex 00430c003010350137700106a2000958
 hex 00576003044003f201420a607c0fa600
 hex 121e290017059d000a2c020875001030
 hex 6e0134000e075900617c7f01007c0157
 hex 011306590010222c005a0e0c20030c9a
 hex 002270063d021220400192030c000440
 hex 01000660d90008ad021b30d8010f0176
 hex 00f2031e18400100400700067f1f6a38
 hex 0c4001000f630150387e00002c0c034a
 hex 39005000810022700f3f0014014a005f
 hex 604001000c017e004f330000600ceb02
 hex 2400042c026230005c1b00422802162c
 hex 49002d1f0380001403bc0113082a021f
 hex 401580000f2178005001006000403800
 hex 133e5601223e029b02477805541fa100
 hex 6f7e03007e0702425a002a3200b10021
 hex 204428001a079f007a30004e00000208
 hex 6d0204ea002f1c22267400260e06ad02
 hex 04ea000141016830003f647c204c013a
 hex 1000005a00190885030f1077002d7001
 hex 9c0029047cdc0104c404762038007031
 hex 0006cb012c0e30570523016080002f78
 hex 0f0ef20153381800781fb50037304003
 hex a20019092e024702040001f201750e40
 hex 1738004001c3002770079d002f400105
 hex 6902581f0000637109027702407b7f07
 hex 0010c304aa3360034001023860000e9a
 hex 00130f210212234001210206cd021a02
 hex d8000440050a9b000f01770012707f00
 hex a37c71004f2008400040014803401e00
 hex 00070c031d332c034630060006c20412
 hex 404c001f08017e001f3e0ee802340660
 hex 07a700621800761e004e7b0016244900
 hex 5c0703011800d90124003cc2032f4001
 hex 4ccc0311402c04210c03c40012303606
 hex 22000cec052a7400a10038380f0a5900
 hex 110691030348030f2973001c13b00424
 hex 7c01b500431e704301a6007a10004c01
 hex 0000049d00130c6b001f0627f3043a0a
 hex 030c300513303f057f10006e07002006
 hex 094d05140cb3001f021373004d401f7f
 hex 019d051a0cb303250001330535730f03
 hex a3006a6003600018009b001f3017e903
 hex 537830037801350136607101a2002a40
 hex 0d59001706df006200001c0033604e00
 hex 0288022850015c060f06e80267010060
 hex 3f5f038103857f466a7d0d001000d800
 hex ba4013205e4101037840010e81002518
 hex 3c9e0200e3022f420307cd061f1810e8
 hex 0634400107df00523078410070d10060
 hex 40471f0000034f001d132c0346600700
 hex 0cd60212604c004f180040011fd60373
 hex 40073000400118c20343460300789a07
 hex 151e4a005a0e420108039b0045030000
 hex 68c2071f004fcc074240134004750002
 hex 72080367054a481b0700a10038000e08
 hex 590014045501000c030f2973002a1100
 hex b100246001b40044701b1066cd083a18
 hex 0000d80805d70c4f4000000227f30436
 hex 3b010cb30a02d10804e10a5766050020
 hex 044d011c3059051f04186a097f607f7f
 hex 417f00400b9c09044c0902e700451e78
 hex 0160cc095a00400008006b021f1007e9
 hex 021c1c2e0b4460030e0f350d205b0310
 hex 0603ce090aad06560606600300c00242
 hex 140020204e0002580018589c091f6009
 hex 680a45010f037c58006966434f3a6d39
 hex 970a8c19307e4001014000ac0a227020
 hex 49001223e100226300cd020f01d3061f
 hex 0c11e80324410fdf0280103c41001c00
 hex 7e016900137f4b004c200f6071810012
 hex 04980b2418783a096f40010010004020
 hex d50382600c1f0000077c1f900723043a
 hex c30235016c1f4a00241e42ef0508b503
 hex 234007d10c1f604dcb0b00e805101653
 hex 0a1570240a0367013a685101a0002c38
 hex 3006020336001340640e0f2477003a40
 hex 1104b1002238033401644003100c1027
 hex cd084d0f000003b0071f062feb0c1725
 hex ac0a17303a0d5a300840630f4a0d1c20
 hex 5905140633010f107205933f00784118
 hex 007041038e071403a6051a005b10255e
 hex 013301560c40006001a5105f070c0040
 hex 0114dc0d2a76012e0200390a14073501
 hex 01ad06102e2d004a03003c0e310f3704
 hex 700f3f0e303c0020a50605bd0c186cdb
 hex 001f2006e8021107290d2506065f0786
 hex 0f583f0f60007000d800321f103ea70e
 hex 2a1c009a0018273e0a40003f00001703
 hex 1f0400d3062f300410e8032438479c02
 hex 901c1c644101060003011e06133a4b00
 hex 4e300b30012e0f01a70033704f0f5101
 hex 0027132f006020d50382266c0100002f
 hex 3c70d10823042e590026314821065d3c
 hex 5e007818b00723000c3a091f204dcb0b
 hex 1178470e560320000400c80311100f06
 hex 2a7300a0002a6e388100150867104f01
 hex 0040702774003a601807b100237c0145
 hex 066306101c506101ce0900e7100acf03
 hex 23010071091f0129f1083567010b5900
 hex 17203a0d8f607f1f0378066006094d11
 hex 1302ea012f40010e7300406001004e22
 hex 0f137f58002f4c0701a6115638007833
 hex 01b3004640072001a5002a0404fe0a2f
 hex 001c06e902393803073103775e61637e
 hex 037f01d702aa403b0040016002600700
 hex 0702370c071f3f0e31680020d7143260
 hex 677daa000759001f2007e70201210270
 hex 6a037c07001c003d1292180e106c0c40
 hex 036001520e70601f00007c300ea70e4a
 hex 030138008100192c71024f7301000804
 hex cf123f600c0e0fe903246c44db04e37e
 hex 040c000102004101001860033e4b003d
 hex 700a1880004506000003340d13184803
 hex 2f38301fd503307c3f361006023c0242
 hex 10000c66290036033f0c210a5e287000
 hex 7870b0131338c0020f4eca1300571430
 hex 3440011b0f069902121c9f120a9f003a
 hex 404f28a911181867141f582774003a20
 hex 7801b1001236380364037e0c187070cc
 hex 1116306d1106780023600362012f0432
 hex 2674003946410ddd00240018b5066710
 hex 0040074003cd180f0758150f0ff20121
 hex 7c0332182340738b02147da515190631
 hex 0323000ce805022b1636072003a50058
 hex 3c0700000f5c021f0605690220406f2e
 hex 0d163d3403517347637f01c504160836
 hex 0379400130062003007800471848055c
 hex bf0231580130cd0231387c4728001812
 hex 5b161f100b6816f3040e00000c703f00
 hex 1c780770030630587c030660cd08613c
 hex 700300602fa6124a4701280081003728
 hex 7003a300511e01000841d0121d039700
 hex 1f0810e803244747c600606f7c180001
 hex 03210f440e70011c4703131fa0170a5b
 hex 002406003a0d130c6c0c2f6f1f1fd503
 hex 1106591a232006650804701948062c64
 hex 0122142a60438000140167001f6050c8
 hex 1313002c1808b3002f783f0241182a40
 hex 69d602173067102f604c2774003a3c28
 hex 00b1001203400177406319184021034d
 hex 013a080002db011530610d1f1627f418
 hex 2a61069e001708e00d07ca010e551114
 hex 032c022f08700ff201430403601fd10c
 hex 64707f03007818a5001a02ae19053c02
 hex 1103c20023201ea5005906000078012b
 hex 0a3f4000020569022060063801263f03
 hex 5e0146076307011b1200510410018b0b
 hex 490420070c7800577058044006c00221
 hex 0118cd02410c70010306030f135b1a14
 hex 040c0ad0130e0007007c1c7e7f215e3b
 hex 0e3c0612786c01500e407f793ca70e3d
 hex 6d00780406277e017c0032010078cf1a
 hex 0d80000030001f300d6b031406ac0662
 hex 6039403c0003a81d157849003f401706
 hex 012d1b1504340d1f0628cc0331030013
 hex c21821000cbc0c130c711536047c6621
 hex 0a005a062c0343b1031a006a000f1500
 hex 000ffe                          
 
     
     
     
     endif
initDataLen     equ .-initData

dataSeg         equ .
                seg.u conwayData                ; uninitialized data segment
                org dataSeg

datapg0         ds.b dataWidth * dataHeight     ; data page 0
datapg0_lastRow equ . - dataWidth - fieldWidth  ; first visible cell of the last row
datapg0_tln     equ . - [n_offset * 3]          ; topleft neighbor of the bottomright-most visible cell
datapg0_end     equ . 

datapg1         ds.b dataWidth * dataHeight     ; data page 1
datapg1_lastRow equ . - dataWidth - fieldWidth  ; first visible cell of the last row
datapg1_tln     equ . - [n_offset * 1]          ; topleft neighbor of the bottomright-most visible cell
datapg1_end     equ . 